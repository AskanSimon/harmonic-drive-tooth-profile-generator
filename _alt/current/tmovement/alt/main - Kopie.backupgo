package main

import (
    "bytes"
    "fmt"
    "log"
    "math"
)

func main() {

    var b bytes.Buffer
    
    b.WriteString("<svg width=\"1200\" height=\"1000\" xmlns=\"http://www.w3.org/2000/svg\">")
    b.WriteString("<g stroke-width=\"0.5\" fill=\"none\">")

    e := Ellipse{Point{600.0, 500.0}, 303.0, 337.0} // px, py, h, w 
    
    b.WriteString(fmt.Sprintf("<line x1=\"%.14f\" y1=\"%.14f\" x2=\"%.14f\" y2=\"%.14f\" style=\"stroke:rgb(255,0,0);stroke-width:0.5\" />", e.X-600, e.Y, e.X+600, e.Y ))
    b.WriteString(fmt.Sprintf("<circle cx=\"%.14f\" cy=\"%.14f\"  r=\"%.14f\" style=\"stroke:rgb(255,0,0);stroke-width:0.5\" />\n", e.X, e.Y, e.Width+40))
    printDot(&b, e.Point, "black")
    
    teeth := 400 
    toothWidth := e.Circumference() / float64(teeth)
    teethMovement := 0.0

    step := 30.0 // 181.0  
    for rotate := 0.0; rotate <= 360.0; rotate += step { // TODO bei <= das = raus

        p, pLast := Point{}, Point{}
        first := true
        total := 0.0
        counter := 0
       
        //fmt.Println(rotate, "radial \t", 1.24 * math.Cos(2.0*dToR(rotate)), "mm \t tangential", 0.67 * math.Cos(2.0*(dToR(rotate)+0.76))+0.23, "mm") 
        
        // first tooth position
        start := 360.0 - rotate + teethMovement
        test := Point{}
        for {
            
            // welcher winkel in der gedrehten ellipse, gibt den absoluten winkel
            test = e.PointByAngleRotated(start, rotate)
            a2 := rToD(math.Atan2(test.Y, test.X))
            
            //fmt.Println(a2, -teethMovement, math.Abs(a2 - -teethMovement))
            
            if a2 > teethMovement {
                start -= 0.0001
            } else {
                start += 0.0001
            }
            if math.Abs(a2 - teethMovement) < 0.001 { 
                break
            }
        }
        fmt.Println("sin ist", math.Sin(dToR(rotate)))
        
        
        teethMovement += math.Abs(math.Sin(dToR(rotate)))
        
        // draw 360 degrees gear from any rotation
        for i := start; i <= 360.0; i += 0.001 {

            p = e.PointByAngleRotated(i, rotate)
            if first {
                printDot(&b, Point{p.X + e.X, p.Y + e.Y}, "red") // 
                first = false
                pLast = p
                counter++
                continue
            }

            // set teeth by distance
            total += p.DistanceTo(&pLast) / 2
            pLast = p
            if total >= (float64(counter) * toothWidth) {
                printDot(&b, Point{p.X + e.X, p.Y + e.Y}, "#7d7c7c")
                counter++
            }

            if counter == teeth {
                break
            }
        }

        for i := 0.0; i < start; i += 0.001 {

            p = e.PointByAngleRotated(i, rotate)
            if first {
                printDot(&b, Point{p.X + e.X, p.Y + e.Y}, "red")
                first = false
                pLast = p
                counter++
                continue
            }

            total += p.DistanceTo(&pLast) / 2
            pLast = p
            if total >= (float64(counter) * toothWidth) {
                printDot(&b, Point{p.X + e.X, p.Y + e.Y}, "#7d7c7c")
                counter++
            }

            if counter == teeth {
                break
            }
        }
    }
    b.WriteString("</g></svg>")

    err := writeSvg(b.Bytes())
    if err != nil {
        log.Fatal(err)
    }
}

/*
        for {
            p := e.PointByAngleRotated(start, rotate)
            a2 := rToD(math.Atan2(p.Y, p.X))

            if a2 > -gearRotation {
                start -= 0.0001
            } else {
                start += 0.0001
            }
            
            if math.Abs(a2 - -gearRotation) < 0.001 {
        }
*/

